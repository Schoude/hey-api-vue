// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zAphiaRecord = z.object({
  AphiaID: z.optional(z.int()).default(127160),
  url: z.optional(z.string()),
  scientificname: z.optional(z.string()),
  authority: z.optional(z.string()),
  taxonRankID: z.optional(z.int()),
  rank: z.optional(z.string()),
  status: z.optional(z.string()),
  unacceptreason: z.optional(z.string()),
  valid_AphiaID: z.optional(z.boolean()),
  valid_name: z.optional(z.string()),
  valid_authority: z.optional(z.string()),
  parentNameUsageID: z.optional(z.int()),
  originalNameUsageID: z.optional(z.int()),
  kingdom: z.optional(z.string()),
  phylum: z.optional(z.string()),
  class: z.optional(z.string()),
  order: z.optional(z.string()),
  family: z.optional(z.string()),
  genus: z.optional(z.string()),
  citation: z.optional(z.string()),
  lsid: z.optional(z.string()),
  isMarine: z.optional(z.boolean()),
  isBrackish: z.optional(z.boolean()),
  isFreshwater: z.optional(z.boolean()),
  isTerrestrial: z.optional(z.boolean()),
  isExtinct: z.optional(z.boolean()),
  match_type: z.optional(z.string()),
  modified: z.optional(z.string()),
});

export const zAphiaRecordFull = z.object({
  '@context': z.optional(
    z.object({
      dc: z.optional(z.string()),
      dct: z.optional(z.string()),
      dwc: z.optional(z.string()),
      schema: z.optional(z.string()),
      rdfs: z.optional(z.string()),
      prov: z.optional(z.string()),
      evt: z.optional(z.string()),
      ann: z.optional(z.string()),
      aphia: z.optional(z.string()),
    }),
  ),
  '@id': z.optional(z.string()),
  '@type': z.optional(z.string()),
  'dwc:type': z.optional(z.string()),
  'schema:identifier': z.optional(z.string()),
  'dwc:scientificNameID': z.optional(z.string()),
  'dwc:parentNameUsageID': z.optional(z.string()),
  'dct:rightsHolder': z.optional(z.string()),
  'dwc:ScientificName': z.optional(z.string()),
  'schema:taxonRank': z.optional(z.string()),
  'dwc:scientificNameRank': z.optional(z.string()),
  'dwc:taxonomicStatus': z.optional(z.string()),
  'schema:parentTaxon': z.optional(z.string()),
  'dwc:scientificNameAuthorship': z.optional(z.string()),
  'aphia:kingdomID': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dwc:kingdom': z.optional(z.string()),
  'aphia:phylumID': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dwc:phylum': z.optional(z.string()),
  'aphia:classID': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dwc:class': z.optional(z.string()),
  'aphia:orderID': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dwc:order': z.optional(z.string()),
  'aphia:familyID': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dwc:family': z.optional(z.string()),
  'aphia:genusID': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dwc:genus': z.optional(z.string()),
  'dwc:specificEpithet': z.optional(z.string()),
  'dct:replaces': z.optional(
    z.array(
      z.object({
        '@id': z.optional(z.string()),
      }),
    ),
  ),
  'dct:source': z.optional(
    z.array(
      z.union([
        z.object({
          '@id': z.optional(z.string()),
        }),
        z.object({
          '@value': z.optional(z.string()),
        }),
      ]),
    ),
  ),
  'schema:sameAs': z.optional(
    z.array(
      z.object({
        '@id': z.optional(z.string()),
      }),
    ),
  ),
  'schema:url': z.optional(
    z.array(
      z.object({
        '@id': z.optional(z.string()),
      }),
    ),
  ),
  'dwc:vernacularName': z.optional(
    z.array(
      z.object({
        '@value': z.optional(z.string()),
        '@language': z.optional(z.string()),
      }),
    ),
  ),
  'aphia:annotated_vernacularName': z.optional(
    z.array(
      z.object({
        'dwc:vernacularName': z.optional(
          z.object({
            '@value': z.optional(z.string()),
            '@language': z.optional(z.string()),
          }),
        ),
        'prov:wasDerivedFrom': z.optional(
          z.array(
            z.object({
              '@id': z.optional(z.string()),
            }),
          ),
        ),
        'evt:editEvent': z.optional(
          z.array(
            z.object({
              'evt:editAuthor': z.optional(
                z.union([
                  z.object({
                    '@id': z.optional(z.string()),
                  }),
                  z.string(),
                ]),
              ),
              'evt:editDate': z.optional(z.string()),
              'evt:editAction': z.optional(z.string()),
            }),
          ),
        ),
      }),
    ),
  ),
  'dc:creator': z.optional(z.string()),
  'dc:contributor': z.optional(z.array(z.string())),
  'dct:created': z.optional(z.iso.datetime()),
  'dct:modified': z.optional(z.iso.datetime()),
  'evt:editEvent': z.optional(
    z.array(
      z.object({
        'evt:editAuthor': z.optional(
          z.union([
            z.object({
              '@id': z.optional(z.string()),
            }),
            z.string(),
          ]),
        ),
        'evt:editDate': z.optional(z.string()),
        'evt:editAction': z.optional(z.string()),
      }),
    ),
  ),
  'dct:bibliographicCitation': z.optional(z.string()),
  'dct:publisher': z.optional(z.string()),
  'dct:license': z.optional(
    z.object({
      '@id': z.optional(z.string()),
    }),
  ),
  'dc:language': z.optional(z.string()),
  'dwc:locationID': z.optional(
    z.array(
      z.object({
        '@id': z.optional(z.string()),
      }),
    ),
  ),
  'aphia:annotated_LocationID': z.optional(
    z.array(
      z.object({
        'dwc:locationID': z.optional(
          z.object({
            '@id': z.optional(z.string()),
          }),
        ),
        'dct:source': z.optional(
          z.object({
            '@id': z.optional(z.string()),
          }),
        ),
        'prov:wasDerivedFrom': z.optional(
          z.object({
            '@id': z.optional(z.string()),
          }),
        ),
        'evt:editEvent': z.optional(
          z.array(
            z.object({
              'evt:editAuthor': z.optional(
                z.union([
                  z.object({
                    '@id': z.optional(z.string()),
                  }),
                  z.string(),
                ]),
              ),
              'evt:editDate': z.optional(z.string()),
              'evt:editAction': z.optional(z.string()),
            }),
          ),
        ),
      }),
    ),
  ),
});

/**
 * AphiaRecords
 */
export const zAphiaRecordsArray = z.array(zAphiaRecord);

/**
 * Classification
 */
export const zClassification = z.object({
  AphiaID: z.optional(z.int()).default(126132),
  rank: z.optional(z.string()),
  scientificname: z.optional(z.string()),
  child: z.optional(z.union([z.lazy((): any => zClassification), z.null()])),
});

/**
 * Distribution
 */
export const zDistribution = z.object({
  locality: z.optional(z.string()),
  locationID: z.optional(z.string()),
  higherGeography: z.optional(z.string()),
  higherGeographyID: z.optional(z.string()),
  recordStatus: z.optional(z.string()),
  typeStatus: z.optional(z.string()),
  establishmentMeans: z.optional(z.union([z.string(), z.null()])),
  invasiveness: z.optional(z.union([z.string(), z.null()])),
  occurrence: z.optional(z.union([z.string(), z.null()])),
  decimalLatitude: z.optional(z.number()),
  decimalLongitude: z.optional(z.number()),
  qualityStatus: z.optional(z.string()),
});

/**
 * Vernacular
 */
export const zVernacular = z.object({
  vernacular: z.optional(z.string()),
  language_code: z.optional(z.string()),
  language: z.optional(z.string()),
});

/**
 * Source
 */
export const zSource = z.object({
  source_id: z.optional(z.int()).default(1),
  use: z.optional(z.string()),
  reference: z.optional(z.string()),
  page: z.optional(z.string()),
  url: z.optional(z.string()),
  link: z.optional(z.string()),
  fulltext: z.optional(z.string()),
  doi: z.optional(z.string()),
});

/**
 * AphiaRank
 */
export const zAphiaRank = z.object({
  taxonRankID: z.optional(z.int()),
  taxonRank: z.optional(z.string()),
  AphiaID: z.optional(z.int()),
  kingdom: z.optional(z.string()),
});

/**
 * AttributeKey
 */
export const zAttributeKey = z.object({
  measurementTypeID: z.optional(z.int()),
  measurementType: z.optional(z.string()),
  input_id: z.optional(z.int()),
  CategoryID: z.optional(z.int()),
  get children() {
    return z.optional(z.array(z.lazy((): any => zAttributeKey)));
  },
});

/**
 * AttributeValue
 */
export const zAttributeValue = z.object({
  measurementValueID: z.optional(z.int()),
  measurementValue: z.optional(z.string()),
  measurementValueCode: z.optional(z.string()),
  get children() {
    return z.optional(z.array(z.lazy((): any => zAttributeValue)));
  },
});

/**
 * AttributeKeyWithValues
 */
export const zAttributeKeyWithValues = z.object({
  measurementTypeID: z.optional(z.int()),
  measurementType: z.optional(z.string()),
  possibleAttributeValues: z.optional(z.array(zAttributeValue)),
  get children() {
    return z.optional(z.array(z.lazy((): any => zAttributeKeyWithValues)));
  },
});

/**
 * Attribute
 */
export const zAttribute = z.object({
  AphiaID: z.optional(z.int()),
  measurementTypeID: z.optional(z.int()),
  measurementType: z.optional(z.string()),
  measurementValue: z.optional(z.string()),
  source_id: z.optional(z.int()),
  reference: z.optional(z.string()),
  qualitystatus: z.optional(z.string()),
  CategoryID: z.optional(z.int()),
  AphiaID_Inherited: z.optional(z.int()),
  get children() {
    return z.optional(z.array(z.lazy((): any => zAttribute)));
  },
});

/**
 * AphiaAttributeSet
 */
export const zAphiaAttributeSet = z.object({
  AphiaID: z.optional(z.int()),
  Attributes: z.optional(z.array(zAttribute)),
});

/**
 * BadRequestError
 */
export const zBadRequestError = z.object({
  code: z.optional(z.int()),
  success: z.optional(z.boolean()),
  errors: z.optional(
    z.array(
      z.object({
        type: z.optional(z.string()),
        message: z.optional(z.string()),
      }),
    ),
  ),
});

export const zAphiaChildrenByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(
    z.object({
      marine_only: z.optional(z.boolean()).default(true),
      extant_only: z.optional(z.boolean()).default(true),
      offset: z.optional(z.int()).default(1),
    }),
  ),
});

export const zAphiaChildrenByAphiaIdResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaClassificationByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

/**
 * Successful operation
 */
export const zAphiaClassificationByAphiaIdResponse = zClassification;

export const zAphiaDistributionsByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zAphiaDistributionsByAphiaIdResponse = z.union([z.array(zDistribution), z.void()]);

export const zAphiaExternalIdByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['algaebase', 'bold', 'dyntaxa', 'fishbase', 'iucn', 'lsid', 'ncbi', 'tsn', 'gisd'])),
    }),
  ),
});

export const zAphiaExternalIdByAphiaIdResponse = z.union([z.array(z.string()), z.void()]);

export const zAphiaIdByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ScientificName: z.string(),
  }),
  query: z.optional(
    z.object({
      marine_only: z.optional(z.boolean()).default(true),
      extant_only: z.optional(z.boolean()).default(true),
    }),
  ),
});

export const zAphiaIdByNameResponse = z.union([z.int(), z.void(), z.unknown()]);

export const zAphiaNameByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zAphiaNameByAphiaIdResponse = z.union([z.string(), z.void()]);

export const zAphiaRecordByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zAphiaRecordByAphiaIdResponse = z.union([zAphiaRecord, z.void()]);

export const zAphiaRecordsByAphiaIdsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    'aphiaids[]': z.array(z.int()),
  }),
});

export const zAphiaRecordsByAphiaIdsResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaRecordByExternalIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.string(),
  }),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['algaebase', 'bold', 'dyntaxa', 'fishbase', 'iucn', 'lsid', 'ncbi', 'tsn', 'gisd'])),
    }),
  ),
});

export const zAphiaRecordByExternalIdResponse = z.union([zAphiaRecord, z.void()]);

export const zAphiaRecordsByDateData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    startdate: z.iso.datetime(),
    enddate: z.optional(z.iso.datetime()),
    marine_only: z.optional(z.boolean()).default(true),
    extant_only: z.optional(z.boolean()).default(true),
    offset: z.optional(z.int()).default(1),
  }),
});

export const zAphiaRecordsByDateResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaRecordsByMatchNamesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    'scientificnames[]': z.array(z.string()),
    'authorships[]': z.optional(z.array(z.string())),
    marine_only: z.optional(z.boolean()).default(true),
    extant_only: z.optional(z.boolean()).default(true),
    match_authority: z.optional(z.boolean()).default(true),
  }),
});

export const zAphiaRecordsByMatchNamesResponse = z.union([z.array(zAphiaRecordsArray), z.void()]);

export const zAphiaRecordsByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ScientificName: z.string(),
  }),
  query: z.optional(
    z.object({
      like: z.optional(z.boolean()).default('true'),
      marine_only: z.optional(z.boolean()).default(true),
      extant_only: z.optional(z.boolean()).default(true),
      offset: z.optional(z.int()).default(1),
    }),
  ),
});

export const zAphiaRecordsByNameResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaRecordsByNamesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    'scientificnames[]': z.array(z.string()),
    like: z.optional(z.boolean()).default('false'),
    marine_only: z.optional(z.boolean()).default(true),
    extant_only: z.optional(z.boolean()).default(true),
  }),
});

export const zAphiaRecordsByNamesResponse = z.union([z.array(zAphiaRecordsArray), z.void()]);

export const zAphiaRecordsByVernacularData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    Vernacular: z.string(),
  }),
  query: z.optional(
    z.object({
      like: z.optional(z.boolean()).default('false'),
      offset: z.optional(z.int()).default('1'),
    }),
  ),
});

export const zAphiaRecordsByVernacularResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaSynonymsByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(
    z.object({
      offset: z.optional(z.int()).default(1),
    }),
  ),
});

export const zAphiaSynonymsByAphiaIdResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaVernacularsByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zAphiaVernacularsByAphiaIdResponse = z.union([z.array(zVernacular), z.void()]);

export const zAphiaSourcesByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zAphiaSourcesByAphiaIdResponse = z.union([z.array(zSource), z.void()]);

export const zAphiaTaxonRanksByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int().default('-1'),
  }),
  query: z.optional(
    z.object({
      AphiaID: z.optional(z.int()),
    }),
  ),
});

export const zAphiaTaxonRanksByIdResponse = z.union([z.array(zAphiaRank), z.void()]);

export const zAphiaTaxonRanksByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    taxonRank: z.string().default(''),
  }),
  query: z.optional(
    z.object({
      AphiaID: z.optional(z.int()),
    }),
  ),
});

export const zAphiaTaxonRanksByNameResponse = z.union([z.array(zAphiaRank), z.void()]);

export const zAphiaRecordsByTaxonRankIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(
    z.object({
      belongsTo: z.optional(z.int()),
      offset: z.optional(z.int()).default(1),
    }),
  ),
});

export const zAphiaRecordsByTaxonRankIdResponse = z.union([z.array(zAphiaRecord), z.void()]);

export const zAphiaFullRecordByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zAphiaFullRecordByAphiaIdResponse = z.union([zAphiaRecordFull, z.void()]);

export const zAphiaAttributeKeysByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int().default('0'),
  }),
  query: z.optional(
    z.object({
      include_children: z.optional(z.boolean()).default('true'),
    }),
  ),
});

export const zAphiaAttributeKeysByIdResponse = z.union([z.array(zAttributeKey), z.void()]);

export const zAphiaAttributeValuesByCategoryIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int().default('0'),
  }),
  query: z.optional(z.never()),
});

export const zAphiaAttributeValuesByCategoryIdResponse = z.union([z.array(zAttributeValue), z.void()]);

export const zAphiaIdsByAttributeKeyIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(
    z.object({
      offset: z.optional(z.int()).default(1),
    }),
  ),
});

export const zAphiaIdsByAttributeKeyIdResponse = z.union([z.array(zAphiaAttributeSet), z.void()]);

export const zAphiaAttributesByAphiaIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ID: z.int(),
  }),
  query: z.optional(
    z.object({
      include_inherited: z.optional(z.boolean()).default('false'),
    }),
  ),
});

export const zAphiaAttributesByAphiaIdResponse = z.union([z.array(zAttribute), z.void()]);

export const zAjaxAphiaRecordsByNamePartData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    NamePart: z.string(),
  }),
  query: z.optional(
    z.object({
      rank_min: z.optional(z.int()).default(10),
      rank_max: z.optional(z.int()).default(280),
      max_matches: z.optional(z.int()).default(20),
      'excluded_ids[]': z.optional(z.array(z.int())),
      combine_vernaculars: z.optional(z.boolean()).default('false'),
      marine_only: z.optional(z.boolean()).default(true),
      fossil_id: z.optional(z.int()).default(0),
      'languages[]': z.optional(z.array(z.string())),
    }),
  ),
});

export const zAjaxAphiaRecordsByNamePartResponse = z.union([z.unknown(), z.void()]);
