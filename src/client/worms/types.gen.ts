// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'https://www.marinespecies.org/rest' | (string & {});
};

export type AphiaRecord = {
  /**
   * Unique and persistent identifier within WoRMS. Primary key in the database --
   */
  AphiaID?: number;
  /**
   * HTTP URL to the AphiaRecord
   */
  url?: string;
  /**
   * The full scientific name without authorship
   */
  scientificname?: string;
  /**
   * The authorship information for the scientificname formatted according to the conventions of the applicable nomenclaturalCode
   */
  authority?: string;
  /**
   * The taxonomic rank identifier of the most specific name in the scientificname
   */
  taxonRankID?: number;
  /**
   * The taxonomic rank of the most specific name in the scientificname
   */
  rank?: string;
  /**
   * The status of the use of the scientificname (usually a taxonomic opinion). Additional technical statuses are (1) <u>quarantined</u>: hidden from public interface after decision from an editor and (2) <u>deleted</u>: AphiaID should NOT be used anymore, please replace it by the valid_AphiaID
   */
  status?: string;
  /**
   * The reason why a scientificname is unaccepted
   */
  unacceptreason?: string;
  /**
   * The AphiaID (for the scientificname) of the currently accepted taxon. NULL if there is no currently accepted taxon.
   */
  valid_AphiaID?: boolean;
  /**
   * The scientificname of the currently accepted taxon
   */
  valid_name?: string;
  /**
   * The authorship information for the scientificname of the currently accepted taxon
   */
  valid_authority?: string;
  /**
   * The AphiaID (for the scientificname) of the direct, most proximate higher-rank parent taxon (in a classification)
   */
  parentNameUsageID?: number;
  /**
   * The AphiaID (for the scientificname) of the original name
   */
  originalNameUsageID?: number;
  /**
   * The full scientific name of the kingdom in which the taxon is classified
   */
  kingdom?: string;
  /**
   * The full scientific name of the phylum or division in which the taxon is classified
   */
  phylum?: string;
  /**
   * The full scientific name of the class in which the taxon is classified
   */
  class?: string;
  /**
   * The full scientific name of the order in which the taxon is classified
   */
  order?: string;
  /**
   * The full scientific name of the family in which the taxon is classified
   */
  family?: string;
  /**
   * The full scientific name of the genus in which the taxon is classified
   */
  genus?: string;
  /**
   * A bibliographic reference for the resource as a statement indicating how this record should be cited (attributed) when used
   */
  citation?: string;
  /**
   * LifeScience Identifier. Persistent GUID for an AphiaID
   */
  lsid?: string;
  /**
   * A boolean flag indicating whether the taxon is a marine organism, i.e. can be found in/above sea water. Possible values: 0/1/NULL
   */
  isMarine?: boolean;
  /**
   * A boolean flag indicating whether the taxon occurs in brackish habitats. Possible values: 0/1/NULL
   */
  isBrackish?: boolean;
  /**
   * A boolean flag indicating whether the taxon occurs in freshwater habitats, i.e. can be found in/above rivers or lakes. Possible values: 0/1/NULL
   */
  isFreshwater?: boolean;
  /**
   * A boolean flag indicating the taxon is a terrestrial organism, i.e. occurs on land as opposed to the sea. Possible values: 0/1/NULL
   */
  isTerrestrial?: boolean;
  /**
   * A flag indicating an extinct organism. Possible values: 0/1/NULL
   */
  isExtinct?: boolean;
  /**
   * Type of match. Possible values: exact/exact_subgenus/exact_replaced/like/phonetic/near_1/near_2/near_3/match_quarantine/match_deleted. See <a href='https://www.marinespecies.org/tutorial_taxonmatch.php' target='_blank'>here</a> (bottom) for a full explanation of the types of matches.
   */
  match_type?: string;
  /**
   * The most recent date-time in GMT on which the resource was changed
   */
  modified?: string;
};

export type AphiaRecordFull = {
  '@context'?: {
    dc?: string;
    dct?: string;
    dwc?: string;
    schema?: string;
    rdfs?: string;
    prov?: string;
    evt?: string;
    ann?: string;
    aphia?: string;
  };
  '@id'?: string;
  '@type'?: string;
  'dwc:type'?: string;
  'schema:identifier'?: string;
  'dwc:scientificNameID'?: string;
  'dwc:parentNameUsageID'?: string;
  'dct:rightsHolder'?: string;
  'dwc:ScientificName'?: string;
  'schema:taxonRank'?: string;
  'dwc:scientificNameRank'?: string;
  'dwc:taxonomicStatus'?: string;
  'schema:parentTaxon'?: string;
  'dwc:scientificNameAuthorship'?: string;
  'aphia:kingdomID'?: {
    '@id'?: string;
  };
  'dwc:kingdom'?: string;
  'aphia:phylumID'?: {
    '@id'?: string;
  };
  'dwc:phylum'?: string;
  'aphia:classID'?: {
    '@id'?: string;
  };
  'dwc:class'?: string;
  'aphia:orderID'?: {
    '@id'?: string;
  };
  'dwc:order'?: string;
  'aphia:familyID'?: {
    '@id'?: string;
  };
  'dwc:family'?: string;
  'aphia:genusID'?: {
    '@id'?: string;
  };
  'dwc:genus'?: string;
  'dwc:specificEpithet'?: string;
  'dct:replaces'?: Array<{
    '@id'?: string;
  }>;
  'dct:source'?: Array<
    | {
        '@id'?: string;
      }
    | {
        '@value'?: string;
      }
  >;
  'schema:sameAs'?: Array<{
    '@id'?: string;
  }>;
  'schema:url'?: Array<{
    '@id'?: string;
  }>;
  'dwc:vernacularName'?: Array<{
    '@value'?: string;
    '@language'?: string;
  }>;
  'aphia:annotated_vernacularName'?: Array<{
    'dwc:vernacularName'?: {
      '@value'?: string;
      '@language'?: string;
    };
    'prov:wasDerivedFrom'?: Array<{
      '@id'?: string;
    }>;
    'evt:editEvent'?: Array<{
      'evt:editAuthor'?:
        | {
            '@id'?: string;
          }
        | string;
      'evt:editDate'?: string;
      'evt:editAction'?: string;
    }>;
  }>;
  'dc:creator'?: string;
  'dc:contributor'?: Array<string>;
  'dct:created'?: string;
  'dct:modified'?: string;
  'evt:editEvent'?: Array<{
    'evt:editAuthor'?:
      | {
          '@id'?: string;
        }
      | string;
    'evt:editDate'?: string;
    'evt:editAction'?: string;
  }>;
  'dct:bibliographicCitation'?: string;
  'dct:publisher'?: string;
  'dct:license'?: {
    '@id'?: string;
  };
  'dc:language'?: string;
  'dwc:locationID'?: Array<{
    '@id'?: string;
  }>;
  'aphia:annotated_LocationID'?: Array<{
    'dwc:locationID'?: {
      '@id'?: string;
    };
    'dct:source'?: {
      '@id'?: string;
    };
    'prov:wasDerivedFrom'?: {
      '@id'?: string;
    };
    'evt:editEvent'?: Array<{
      'evt:editAuthor'?:
        | {
            '@id'?: string;
          }
        | string;
      'evt:editDate'?: string;
      'evt:editAction'?: string;
    }>;
  }>;
};

/**
 * AphiaRecords
 */
export type AphiaRecordsArray = Array<AphiaRecord>;

/**
 * Classification
 */
export type Classification = {
  AphiaID?: number;
  rank?: string;
  scientificname?: string;
  child?: Classification | null;
};

/**
 * Distribution
 */
export type Distribution = {
  /**
   * The specific description of the place
   */
  locality?: string;
  /**
   * An identifier for the locality. Using the Marine Regions Geographic IDentifier (MRGID), see <a href='https://www.marineregions.org/mrgid.php' target='_blank'>https://www.marineregions.org/mrgid.php</a>
   */
  locationID?: string;
  /**
   * A geographic name less specific than the information captured in the locality term. Possible values: an IHO Sea Area or Nation, derived from the MarineRegions <a href='https://www.marineregions.org/gazetteer.php' target='_blank'>gazetteer</a>
   */
  higherGeography?: string;
  /**
   * An identifier for the geographic region within which the locality occurred, using MRGID
   */
  higherGeographyID?: string;
  /**
   * The status of the distribution record. Possible values are 'valid' ,'doubtful' or 'inaccurate'. See <a href='https://www.marinespecies.org/aphia.php?p=manual#topic8b' target=_blank>here</a> for explanation of the statuses
   */
  recordStatus?: string;
  /**
   * The type status of the distribution. Possible values: &#039;holotype&#039; or empty.
   */
  typeStatus?: string;
  /**
   * The process by which the biological individual(s) represented in the Occurrence became established at the location. Possible values: values listed as Origin <a href='https://www.marinespecies.org/introduced/terminology.php#:~:text=Origin,Origin%20unknown' target=_blank>in WRiMS</a>
   */
  establishmentMeans?: string | null;
  /**
   * The invasiveness of the species. Possible values: values listed as Invasiveness <a href='https://www.marinespecies.org/introduced/terminology.php#:~:text=Invasiveness,or%20hull%20fouling%3B' target=_blank>in WRiMS</a>
   */
  invasiveness?: string | null;
  /**
   * The occurence status. Possible values: values listed as Occurrence <a href='https://www.marinespecies.org/introduced/terminology.php#:~:text=Occurrence,Sometimes%20present' target=_blank>in WRiMS</a>
   */
  occurrence?: string | null;
  /**
   * The geographic latitude (in decimal degrees, WGS84)
   */
  decimalLatitude?: number;
  /**
   * The geographic longitude (in decimal degrees, WGS84)
   */
  decimalLongitude?: number;
  /**
   * Quality status of the record. Possible values: 'checked', 'trusted' or 'unreviewed'. See <a href='https://www.marinespecies.org/aphia.php?p=manual#topic22' target='_blank'>here</a>
   */
  qualityStatus?: string;
};

/**
 * Vernacular
 */
export type Vernacular = {
  vernacular?: string;
  language_code?: string;
  language?: string;
};

/**
 * Source
 */
export type Source = {
  /**
   * Unique identifier for the source within WoRMS
   */
  source_id?: number;
  /**
   * Usage of the source for this taxon. See <a href='https://www.marinespecies.org/aphia.php?p=manual#topic6' target='_blank'>here</a> for all values
   */
  use?: string;
  /**
   * Full citation string
   */
  reference?: string;
  /**
   * Page(s) where the taxon is mentioned
   */
  page?: string;
  /**
   * Direct link to the source record
   */
  url?: string;
  /**
   * External link (i.e. journal, data system, etc..)
   */
  link?: string;
  /**
   * Full text link (PDF)
   */
  fulltext?: string;
  /**
   * Digital Object Identifier
   */
  doi?: string;
};

/**
 * AphiaRank
 */
export type AphiaRank = {
  /**
   * A taxonomic rank identifier
   */
  taxonRankID?: number;
  /**
   * A taxonomic rank name
   */
  taxonRank?: string;
  /**
   * The AphiaID of the kingdom
   */
  AphiaID?: number;
  /**
   * The name of a taxonomic kingdom the rank is used in
   */
  kingdom?: string;
};

/**
 * AttributeKey
 */
export type AttributeKey = {
  /**
   * An internal identifier for the measurementType
   */
  measurementTypeID?: number;
  /**
   * The nature of the measurement, fact, characteristic, or assertion <a href='https://www.marinespecies.org/traits/wiki' target='_blank'>https://www.marinespecies.org/traits/wiki</a>
   */
  measurementType?: string;
  /**
   * The data type that is expected as value for this attribute definition
   */
  input_id?: number;
  /**
   * The category identifier to list possible attribute values for this attribute definition
   */
  CategoryID?: number;
  /**
   * The possible child attribute keys that help to describe to current attribute
   */
  children?: Array<AttributeKey>;
};

/**
 * AttributeKeyWithValues
 */
export type AttributeKeyWithValues = {
  /**
   * An internal identifier for the measurementType
   */
  measurementTypeID?: number;
  /**
   * The nature of the measurement, fact, characteristic, or assertion <a href='https://www.marinespecies.org/traits/wiki' target='_blank'>https://www.marinespecies.org/traits/wiki</a>
   */
  measurementType?: string;
  /**
   * The category definition that list possible attribute values for this attribute definition
   */
  possibleAttributeValues?: Array<AttributeValue>;
  /**
   * The possible child attribute keys that help to describe to current attribute
   */
  children?: Array<AttributeKeyWithValues>;
};

/**
 * AttributeValue
 */
export type AttributeValue = {
  /**
   * An identifier for facts stored in the column measurementValue
   */
  measurementValueID?: number;
  /**
   * The value of the measurement, fact, characteristic, or assertion
   */
  measurementValue?: string;
  /**
   * Additional info/code that helps to the describe/define the measurementValue
   */
  measurementValueCode?: string;
  /**
   * Child measurementValues that are more specific
   */
  children?: Array<AttributeValue>;
};

/**
 * Attribute
 */
export type Attribute = {
  /**
   * Unique and persistent identifier within WoRMS
   */
  AphiaID?: number;
  /**
   * The corresponding AttributeKey its measurementTypeID
   */
  measurementTypeID?: number;
  /**
   * The corresponding AttributeKey its measurementType
   */
  measurementType?: string;
  /**
   * The value of the measurement, fact, characteristic, or assertion
   */
  measurementValue?: string;
  /**
   * The identifier for the AphiaSource for this attribute
   */
  source_id?: number;
  /**
   * The AphiaSource reference for this attribute
   */
  reference?: string;
  /**
   * Quality status of the record. Possible values: 'checked', 'trusted' or 'unreviewed'. See <a href='https://www.marinespecies.org/aphia.php?p=manual#topic22' target='_blank'>here</a>
   */
  qualitystatus?: string;
  /**
   * The category identifier to list possible attribute values for this attribute definition
   */
  CategoryID?: number;
  /**
   * The AphiaID from where this attribute is inherited
   */
  AphiaID_Inherited?: number;
  /**
   * The possible child attributes that help to describe to current attribute
   */
  children?: Array<Attribute>;
};

/**
 * AphiaAttributeSet
 */
export type AphiaAttributeSet = {
  /**
   * Unique and persistent identifier within WoRMS. Primary key in the database
   */
  AphiaID?: number;
  Attributes?: Array<Attribute>;
};

/**
 * BadRequestError
 */
export type BadRequestError = {
  code?: number;
  success?: boolean;
  errors?: Array<{
    type?: string;
    message?: string;
  }>;
};

export type AphiaChildrenByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: {
    /**
     * Limit to marine taxa
     */
    marine_only?: boolean;
    /**
     * Limit to extant taxa
     */
    extant_only?: boolean;
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaChildrenByAphiaID/{ID}';
};

export type AphiaChildrenByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaChildrenByAphiaIdError = AphiaChildrenByAphiaIdErrors[keyof AphiaChildrenByAphiaIdErrors];

export type AphiaChildrenByAphiaIdResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaChildrenByAphiaIdResponse = AphiaChildrenByAphiaIdResponses[keyof AphiaChildrenByAphiaIdResponses];

export type AphiaClassificationByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaClassificationByAphiaID/{ID}';
};

export type AphiaClassificationByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaClassificationByAphiaIdError =
  AphiaClassificationByAphiaIdErrors[keyof AphiaClassificationByAphiaIdErrors];

export type AphiaClassificationByAphiaIdResponses = {
  /**
   * Successful operation
   */
  200: Classification;
};

export type AphiaClassificationByAphiaIdResponse =
  AphiaClassificationByAphiaIdResponses[keyof AphiaClassificationByAphiaIdResponses];

export type AphiaDistributionsByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaDistributionsByAphiaID/{ID}';
};

export type AphiaDistributionsByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaDistributionsByAphiaIdError =
  AphiaDistributionsByAphiaIdErrors[keyof AphiaDistributionsByAphiaIdErrors];

export type AphiaDistributionsByAphiaIdResponses = {
  /**
   * Distributions
   *
   * Successful operation
   */
  200: Array<Distribution>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaDistributionsByAphiaIdResponse =
  AphiaDistributionsByAphiaIdResponses[keyof AphiaDistributionsByAphiaIdResponses];

export type AphiaExternalIdByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: {
    /**
     * Type of external identifier to return. The type should be one of the following values:<br/> <ul> <li><u>algaebase</u>: Algaebase species ID</li> <li><u>bold</u>: Barcode of Life Database (BOLD) TaxID</li> <li><u>dyntaxa</u>: Dyntaxa ID</li> <li><u>fishbase</u>: FishBase species ID</li> <li><u>iucn</u>: IUCN Red List Identifier</li> <li><u>lsid</u>: Life Science Identifier</li> <li><u>ncbi</u>: NCBI Taxonomy ID (Genbank)</li> <li><u>tsn</u>: ITIS Taxonomic Serial Number</li> <li><u>gisd</u>: Global Invasive Species Database</li> </ul>
     */
    type?: 'algaebase' | 'bold' | 'dyntaxa' | 'fishbase' | 'iucn' | 'lsid' | 'ncbi' | 'tsn' | 'gisd';
  };
  url: '/AphiaExternalIDByAphiaID/{ID}';
};

export type AphiaExternalIdByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaExternalIdByAphiaIdError = AphiaExternalIdByAphiaIdErrors[keyof AphiaExternalIdByAphiaIdErrors];

export type AphiaExternalIdByAphiaIdResponses = {
  /**
   * Results
   *
   * Successful operation
   */
  200: Array<string>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaExternalIdByAphiaIdResponse =
  AphiaExternalIdByAphiaIdResponses[keyof AphiaExternalIdByAphiaIdResponses];

export type AphiaIdByNameData = {
  body?: never;
  path: {
    /**
     * Name to search for
     */
    ScientificName: string;
  };
  query?: {
    /**
     * Limit to marine taxa
     */
    marine_only?: boolean;
    /**
     * Limit to extant taxa
     */
    extant_only?: boolean;
  };
  url: '/AphiaIDByName/{ScientificName}';
};

export type AphiaIdByNameErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaIdByNameError = AphiaIdByNameErrors[keyof AphiaIdByNameErrors];

export type AphiaIdByNameResponses = {
  /**
   * Successful operation
   */
  200: number;
  /**
   * Nothing found
   */
  204: void;
  /**
   * No content due to multiple results
   */
  206: unknown;
};

export type AphiaIdByNameResponse = AphiaIdByNameResponses[keyof AphiaIdByNameResponses];

export type AphiaNameByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaNameByAphiaID/{ID}';
};

export type AphiaNameByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaNameByAphiaIdError = AphiaNameByAphiaIdErrors[keyof AphiaNameByAphiaIdErrors];

export type AphiaNameByAphiaIdResponses = {
  /**
   * Successful operation
   */
  200: string;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaNameByAphiaIdResponse = AphiaNameByAphiaIdResponses[keyof AphiaNameByAphiaIdResponses];

export type AphiaRecordByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaRecordByAphiaID/{ID}';
};

export type AphiaRecordByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordByAphiaIdError = AphiaRecordByAphiaIdErrors[keyof AphiaRecordByAphiaIdErrors];

export type AphiaRecordByAphiaIdResponses = {
  /**
   * Successful operation
   */
  200: AphiaRecord;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordByAphiaIdResponse = AphiaRecordByAphiaIdResponses[keyof AphiaRecordByAphiaIdResponses];

export type AphiaRecordsByAphiaIdsData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The AphiaID&#039;s to search for
     */
    'aphiaids[]': Array<number>;
  };
  url: '/AphiaRecordsByAphiaIDs';
};

export type AphiaRecordsByAphiaIdsErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByAphiaIdsError = AphiaRecordsByAphiaIdsErrors[keyof AphiaRecordsByAphiaIdsErrors];

export type AphiaRecordsByAphiaIdsResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByAphiaIdsResponse = AphiaRecordsByAphiaIdsResponses[keyof AphiaRecordsByAphiaIdsResponses];

export type AphiaRecordByExternalIdData = {
  body?: never;
  path: {
    /**
     * The external identifier to search for
     */
    ID: string;
  };
  query?: {
    /**
     * Type of external identifier to search for. The type should be one of the following values:<br/> <ul> <li><u>algaebase</u>: Algaebase species ID</li> <li><u>bold</u>: Barcode of Life Database (BOLD) TaxID</li> <li><u>dyntaxa</u>: Dyntaxa ID</li> <li><u>fishbase</u>: FishBase species ID</li> <li><u>iucn</u>: IUCN Red List Identifier</li> <li><u>lsid</u>: Life Science Identifier</li> <li><u>ncbi</u>: NCBI Taxonomy ID (Genbank)</li> <li><u>tsn</u>: ITIS Taxonomic Serial Number</li> <li><u>gisd</u>: Global Invasive Species Database</li> </ul>
     */
    type?: 'algaebase' | 'bold' | 'dyntaxa' | 'fishbase' | 'iucn' | 'lsid' | 'ncbi' | 'tsn' | 'gisd';
  };
  url: '/AphiaRecordByExternalID/{ID}';
};

export type AphiaRecordByExternalIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordByExternalIdError = AphiaRecordByExternalIdErrors[keyof AphiaRecordByExternalIdErrors];

export type AphiaRecordByExternalIdResponses = {
  /**
   * Successful operation
   */
  200: AphiaRecord;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordByExternalIdResponse = AphiaRecordByExternalIdResponses[keyof AphiaRecordByExternalIdResponses];

export type AphiaRecordsByDateData = {
  body?: never;
  path?: never;
  query: {
    /**
     * ISO 8601 formatted start date(time). Default=today(). i.e. 2026-01-21T21:32:38+01:00
     */
    startdate: string;
    /**
     * ISO 8601 formatted end date(time). Default=today(). i.e. 2026-01-21T21:32:38+01:00
     */
    enddate?: string;
    /**
     * Limit to marine taxa
     */
    marine_only?: boolean;
    /**
     * Limit to extant taxa
     */
    extant_only?: boolean;
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaRecordsByDate';
};

export type AphiaRecordsByDateErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByDateError = AphiaRecordsByDateErrors[keyof AphiaRecordsByDateErrors];

export type AphiaRecordsByDateResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByDateResponse = AphiaRecordsByDateResponses[keyof AphiaRecordsByDateResponses];

export type AphiaRecordsByMatchNamesData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Names to search for
     */
    'scientificnames[]': Array<string>;
    /**
     * The authorities of the given names
     */
    'authorships[]'?: Array<string>;
    /**
     * Limit to marine taxa
     */
    marine_only?: boolean;
    /**
     * Limit to extant taxa
     */
    extant_only?: boolean;
    /**
     * Use the authority in the matching process
     */
    match_authority?: boolean;
  };
  url: '/AphiaRecordsByMatchNames';
};

export type AphiaRecordsByMatchNamesErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByMatchNamesError = AphiaRecordsByMatchNamesErrors[keyof AphiaRecordsByMatchNamesErrors];

export type AphiaRecordsByMatchNamesResponses = {
  /**
   * AphiaRecordsArray
   *
   * Successful operation
   */
  200: Array<AphiaRecordsArray>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByMatchNamesResponse =
  AphiaRecordsByMatchNamesResponses[keyof AphiaRecordsByMatchNamesResponses];

export type AphiaRecordsByNameData = {
  body?: never;
  path: {
    /**
     * Name to search for
     */
    ScientificName: string;
  };
  query?: {
    /**
     * Add a &#039;%&#039;-sign added after the ScientificName (SQL LIKE function). Default=true
     */
    like?: boolean;
    /**
     * Limit to marine taxa
     */
    marine_only?: boolean;
    /**
     * Limit to extant taxa
     */
    extant_only?: boolean;
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaRecordsByName/{ScientificName}';
};

export type AphiaRecordsByNameErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByNameError = AphiaRecordsByNameErrors[keyof AphiaRecordsByNameErrors];

export type AphiaRecordsByNameResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByNameResponse = AphiaRecordsByNameResponses[keyof AphiaRecordsByNameResponses];

export type AphiaRecordsByNamesData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Names to search for
     */
    'scientificnames[]': Array<string>;
    /**
     * Add a &#039;%&#039;-sign after the ScientificName (SQL LIKE function). Default=false
     */
    like?: boolean;
    /**
     * Limit to marine taxa
     */
    marine_only?: boolean;
    /**
     * Limit to extant taxa
     */
    extant_only?: boolean;
  };
  url: '/AphiaRecordsByNames';
};

export type AphiaRecordsByNamesErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByNamesError = AphiaRecordsByNamesErrors[keyof AphiaRecordsByNamesErrors];

export type AphiaRecordsByNamesResponses = {
  /**
   * AphiaRecordsArray
   *
   * Successful operation
   */
  200: Array<AphiaRecordsArray>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByNamesResponse = AphiaRecordsByNamesResponses[keyof AphiaRecordsByNamesResponses];

export type AphiaRecordsByVernacularData = {
  body?: never;
  path: {
    /**
     * The vernacular to find records for
     */
    Vernacular: string;
  };
  query?: {
    /**
     * Add a &#039;%&#039;-sign before and after the input (SQL LIKE &#039;%vernacular%&#039; function). Default=false
     */
    like?: boolean;
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaRecordsByVernacular/{Vernacular}';
};

export type AphiaRecordsByVernacularErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByVernacularError = AphiaRecordsByVernacularErrors[keyof AphiaRecordsByVernacularErrors];

export type AphiaRecordsByVernacularResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByVernacularResponse =
  AphiaRecordsByVernacularResponses[keyof AphiaRecordsByVernacularResponses];

export type AphiaSynonymsByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: {
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaSynonymsByAphiaID/{ID}';
};

export type AphiaSynonymsByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaSynonymsByAphiaIdError = AphiaSynonymsByAphiaIdErrors[keyof AphiaSynonymsByAphiaIdErrors];

export type AphiaSynonymsByAphiaIdResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaSynonymsByAphiaIdResponse = AphiaSynonymsByAphiaIdResponses[keyof AphiaSynonymsByAphiaIdResponses];

export type AphiaVernacularsByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaVernacularsByAphiaID/{ID}';
};

export type AphiaVernacularsByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaVernacularsByAphiaIdError = AphiaVernacularsByAphiaIdErrors[keyof AphiaVernacularsByAphiaIdErrors];

export type AphiaVernacularsByAphiaIdResponses = {
  /**
   * Vernaculars
   *
   * Successful operation
   */
  200: Array<Vernacular>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaVernacularsByAphiaIdResponse =
  AphiaVernacularsByAphiaIdResponses[keyof AphiaVernacularsByAphiaIdResponses];

export type AphiaSourcesByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaSourcesByAphiaID/{ID}';
};

export type AphiaSourcesByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaSourcesByAphiaIdError = AphiaSourcesByAphiaIdErrors[keyof AphiaSourcesByAphiaIdErrors];

export type AphiaSourcesByAphiaIdResponses = {
  /**
   * Sources
   *
   * Successful operation
   */
  200: Array<Source>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaSourcesByAphiaIdResponse = AphiaSourcesByAphiaIdResponses[keyof AphiaSourcesByAphiaIdResponses];

export type AphiaTaxonRanksByIdData = {
  body?: never;
  path: {
    /**
     * A taxonomic rank identifier. Default=-1
     */
    ID: number;
  };
  query?: {
    /**
     * The AphiaID of the kingdom
     */
    AphiaID?: number;
  };
  url: '/AphiaTaxonRanksByID/{ID}';
};

export type AphiaTaxonRanksByIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaTaxonRanksByIdError = AphiaTaxonRanksByIdErrors[keyof AphiaTaxonRanksByIdErrors];

export type AphiaTaxonRanksByIdResponses = {
  /**
   * AphiaRanks
   *
   * Successful operation
   */
  200: Array<AphiaRank>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaTaxonRanksByIdResponse = AphiaTaxonRanksByIdResponses[keyof AphiaTaxonRanksByIdResponses];

export type AphiaTaxonRanksByNameData = {
  body?: never;
  path: {
    /**
     * A taxonomic rank. Default=empty
     */
    taxonRank: string;
  };
  query?: {
    /**
     * The AphiaID of the kingdom
     */
    AphiaID?: number;
  };
  url: '/AphiaTaxonRanksByName/{taxonRank}';
};

export type AphiaTaxonRanksByNameErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaTaxonRanksByNameError = AphiaTaxonRanksByNameErrors[keyof AphiaTaxonRanksByNameErrors];

export type AphiaTaxonRanksByNameResponses = {
  /**
   * AphiaRanks
   *
   * Successful operation
   */
  200: Array<AphiaRank>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaTaxonRanksByNameResponse = AphiaTaxonRanksByNameResponses[keyof AphiaTaxonRanksByNameResponses];

export type AphiaRecordsByTaxonRankIdData = {
  body?: never;
  path: {
    /**
     * A taxonomic rank identifier
     */
    ID: number;
  };
  query?: {
    /**
     * Limit the results to descendants of the given AphiaID
     */
    belongsTo?: number;
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaRecordsByTaxonRankID/{ID}';
};

export type AphiaRecordsByTaxonRankIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaRecordsByTaxonRankIdError = AphiaRecordsByTaxonRankIdErrors[keyof AphiaRecordsByTaxonRankIdErrors];

export type AphiaRecordsByTaxonRankIdResponses = {
  /**
   * AphiaRecords
   *
   * Successful operation
   */
  200: Array<AphiaRecord>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaRecordsByTaxonRankIdResponse =
  AphiaRecordsByTaxonRankIdResponses[keyof AphiaRecordsByTaxonRankIdResponses];

export type AphiaFullRecordByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaRecordFullByAphiaID/{ID}';
};

export type AphiaFullRecordByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaFullRecordByAphiaIdError = AphiaFullRecordByAphiaIdErrors[keyof AphiaFullRecordByAphiaIdErrors];

export type AphiaFullRecordByAphiaIdResponses = {
  /**
   * Successful operation
   */
  200: AphiaRecordFull;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaFullRecordByAphiaIdResponse =
  AphiaFullRecordByAphiaIdResponses[keyof AphiaFullRecordByAphiaIdResponses];

export type AphiaAttributeKeysByIdData = {
  body?: never;
  path: {
    /**
     * The attribute definition id to search for
     */
    ID: number;
  };
  query?: {
    /**
     * Include the tree of children. Default=true
     */
    include_children?: boolean;
  };
  url: '/AphiaAttributeKeysByID/{ID}';
};

export type AphiaAttributeKeysByIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaAttributeKeysByIdError = AphiaAttributeKeysByIdErrors[keyof AphiaAttributeKeysByIdErrors];

export type AphiaAttributeKeysByIdResponses = {
  /**
   * AttributeKeys
   *
   * Successful operation
   */
  200: Array<AttributeKey>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaAttributeKeysByIdResponse = AphiaAttributeKeysByIdResponses[keyof AphiaAttributeKeysByIdResponses];

export type AphiaAttributeValuesByCategoryIdData = {
  body?: never;
  path: {
    /**
     * The CateogryID to search for
     */
    ID: number;
  };
  query?: never;
  url: '/AphiaAttributeValuesByCategoryID/{ID}';
};

export type AphiaAttributeValuesByCategoryIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaAttributeValuesByCategoryIdError =
  AphiaAttributeValuesByCategoryIdErrors[keyof AphiaAttributeValuesByCategoryIdErrors];

export type AphiaAttributeValuesByCategoryIdResponses = {
  /**
   * AttributeValues
   *
   * Successful operation
   */
  200: Array<AttributeValue>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaAttributeValuesByCategoryIdResponse =
  AphiaAttributeValuesByCategoryIdResponses[keyof AphiaAttributeValuesByCategoryIdResponses];

export type AphiaIdsByAttributeKeyIdData = {
  body?: never;
  path: {
    /**
     * The attribute definition id to search for
     */
    ID: number;
  };
  query?: {
    /**
     * Starting recordnumber, when retrieving next chunk of (50) records. Default=1
     */
    offset?: number;
  };
  url: '/AphiaIDsByAttributeKeyID/{ID}';
};

export type AphiaIdsByAttributeKeyIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaIdsByAttributeKeyIdError = AphiaIdsByAttributeKeyIdErrors[keyof AphiaIdsByAttributeKeyIdErrors];

export type AphiaIdsByAttributeKeyIdResponses = {
  /**
   * AphiaAttributeSets
   *
   * Successful operation
   */
  200: Array<AphiaAttributeSet>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaIdsByAttributeKeyIdResponse =
  AphiaIdsByAttributeKeyIdResponses[keyof AphiaIdsByAttributeKeyIdResponses];

export type AphiaAttributesByAphiaIdData = {
  body?: never;
  path: {
    /**
     * The AphiaID to search for
     */
    ID: number;
  };
  query?: {
    /**
     * Include attributes inherited from the taxon its parent(s). Default=false
     */
    include_inherited?: boolean;
  };
  url: '/AphiaAttributesByAphiaID/{ID}';
};

export type AphiaAttributesByAphiaIdErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AphiaAttributesByAphiaIdError = AphiaAttributesByAphiaIdErrors[keyof AphiaAttributesByAphiaIdErrors];

export type AphiaAttributesByAphiaIdResponses = {
  /**
   * Attributes
   *
   * Successful operation
   */
  200: Array<Attribute>;
  /**
   * Nothing found
   */
  204: void;
};

export type AphiaAttributesByAphiaIdResponse =
  AphiaAttributesByAphiaIdResponses[keyof AphiaAttributesByAphiaIdResponses];

export type AjaxAphiaRecordsByNamePartData = {
  body?: never;
  path: {
    /**
     * The prefix to use to search for taxa.
     */
    NamePart: string;
  };
  query?: {
    /**
     * The minimum rank of the returned suggestion. Default: 10
     */
    rank_min?: number;
    /**
     * The maximum rank of the returned suggestion. Default: 280
     */
    rank_max?: number;
    /**
     * The maximum number of suggestion to return. Default: 20, Max: 50
     */
    max_matches?: number;
    /**
     * AphiaID&#039;s to exclude from the resultset
     */
    'excluded_ids[]'?: Array<number>;
    /**
     * When true the name can also match vernaculars
     */
    combine_vernaculars?: boolean;
    /**
     * Defines if we search for marine taxa only
     */
    marine_only?: boolean;
    /**
     * Determines the search behavior for fossil taxa (same as for normal search).
     */
    fossil_id?: number;
    /**
     * List of ISO 639-3 language codes to filter search results. Example: &#039;eng&#039;, &#039;nld&#039;, &#039;fra&#039;, &#039;deu&#039;
     */
    'languages[]'?: Array<string>;
  };
  url: '/AjaxAphiaRecordsByNamePart/{NamePart}';
};

export type AjaxAphiaRecordsByNamePartErrors = {
  /**
   * Bad or missing properties
   */
  400: BadRequestError;
};

export type AjaxAphiaRecordsByNamePartError = AjaxAphiaRecordsByNamePartErrors[keyof AjaxAphiaRecordsByNamePartErrors];

export type AjaxAphiaRecordsByNamePartResponses = {
  /**
   * Successful operation
   */
  200: unknown;
  /**
   * Nothing found
   */
  204: void;
};

export type AjaxAphiaRecordsByNamePartResponse =
  AjaxAphiaRecordsByNamePartResponses[keyof AjaxAphiaRecordsByNamePartResponses];
